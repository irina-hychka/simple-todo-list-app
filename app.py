# app.py (v2 with filters & bulk delete)
# -----------------------------------------------------------------------------
# Minimal Flask + SQLAlchemy To-Do API with:
# - SQLite (local) or any SQL DB via DATABASE_URL
# - CRUD endpoints
# - Status filters (all|active|completed)
# - Bulk delete (all|completed|active)
# - Health endpoint for simple checks / future load balancer probes
#
# Notes:
# - Designed for local use first; can be lifted to AWS by switching DATABASE_URL.
# - Keeps the code small and explicit; session handling is manual per endpoint.
# -----------------------------------------------------------------------------

import os
from datetime import datetime
from flask import Flask, render_template, request, jsonify
from sqlalchemy import create_engine, Column, Integer, String, Boolean, DateTime
from sqlalchemy.orm import declarative_base, sessionmaker, scoped_session

# -----------------------------------------------------------------------------
# Database configuration
# -----------------------------------------------------------------------------
# If DATABASE_URL is not set, default to SQLite file in the project folder.
# Examples:
#   sqlite:///todo.db
#   postgresql+psycopg2://user:pass@host:5432/dbname
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///todo.db")

Base = declarative_base()
engine = create_engine(DATABASE_URL, future=True)

# scoped_session gives us a thread-local session registry (safe for simple apps).
SessionLocal = scoped_session(
    sessionmaker(bind=engine, autoflush=False, autocommit=False)
)

# -----------------------------------------------------------------------------
# Flask application
# -----------------------------------------------------------------------------
app = Flask(__name__)


class Task(Base):
    """
    ORM entity for a simple to-do item.

    Fields:
      - id (int, PK): unique identifier
      - title (str): short human-readable task title (required, â‰¤ 255 chars)
      - is_done (bool): completion flag (default: False)
      - created_at (datetime, UTC): creation timestamp
    """

    __tablename__ = "tasks"
    id = Column(Integer, primary_key=True)
    title = Column(String(255), nullable=False)
    is_done = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)


# Create the schema if it does not exist (safe for local/dev use).
Base.metadata.create_all(bind=engine)


# -----------------------------------------------------------------------------
# API: Queries
# -----------------------------------------------------------------------------
@app.route("/api/tasks", methods=["GET"])
def get_tasks():
    """
    Return tasks with optional status filter.

    Query params:
      - status: "all" (default) | "active" | "completed"

    Response:
      200 OK
      [
        {"id": 1, "title": "...", "is_done": false, "created_at": "ISO8601"},
        ...
      ]
    """
    status = request.args.get("status", "all")
    db = SessionLocal()
    try:
        q = db.query(Task)
        if status == "active":
            q = q.filter(Task.is_done == False)  # noqa: E712 (SQLAlchemy boolean)
        elif status == "completed":
            q = q.filter(Task.is_done == True)  # noqa: E712
        tasks = q.order_by(Task.created_at.desc()).all()
        return jsonify(
            [
                {
                    "id": t.id,
                    "title": t.title,
                    "is_done": t.is_done,
                    "created_at": t.created_at.isoformat(),
                }
                for t in tasks
            ]
        )
    finally:
        # Ensure the session is always closed even if something goes wrong.
        db.close()


# -----------------------------------------------------------------------------
# API: Create
# -----------------------------------------------------------------------------
@app.route("/api/tasks", methods=["POST"])
def add_task():
    """
    Create a new task.

    Request JSON:
      { "title": "Buy milk" }

    Validations:
      - title is required and trimmed (non-empty)

    Responses:
      200 OK with created task JSON
      400 Bad Request if title missing/empty
    """
    data = request.json or {}
    title = (data.get("title") or "").strip()
    if not title:
        return jsonify({"error": "title required"}), 400

    db = SessionLocal()
    try:
        task = Task(title=title)
        db.add(task)
        db.commit()
        db.refresh(task)  # populate autogenerated fields (id, created_at)
        return jsonify(
            {
                "id": task.id,
                "title": task.title,
                "is_done": task.is_done,
                "created_at": task.created_at.isoformat(),
            }
        )
    finally:
        db.close()


# -----------------------------------------------------------------------------
# API: Toggle
# -----------------------------------------------------------------------------
@app.route("/api/tasks/<int:task_id>/toggle", methods=["PATCH"])
def toggle_task(task_id):
    """
    Flip the 'is_done' flag for a given task.

    Path params:
      - task_id (int)

    Responses:
      200 OK with updated task JSON
      404 Not Found if task does not exist
    """
    db = SessionLocal()
    try:
        # .get(pk) is fine here (SQLAlchemy 2.x emits a deprecation warning for legacy loader
        # patterns in some contexts; for small apps it's OK).
        task = db.query(Task).get(task_id)
        if not task:
            return jsonify({"error": "not found"}), 404
        task.is_done = not task.is_done
        db.commit()
        db.refresh(task)
        return jsonify(
            {
                "id": task.id,
                "title": task.title,
                "is_done": task.is_done,
                "created_at": task.created_at.isoformat(),
            }
        )
    finally:
        db.close()


# -----------------------------------------------------------------------------
# API: Delete (single)
# -----------------------------------------------------------------------------
@app.route("/api/tasks/<int:task_id>", methods=["DELETE"])
def delete_task(task_id):
    """
    Delete a single task by id.

    Path params:
      - task_id (int)

    Responses:
      204 No Content on success
      404 Not Found if task does not exist
    """
    db = SessionLocal()
    try:
        task = db.query(Task).get(task_id)
        if not task:
            return jsonify({"error": "not found"}), 404
        db.delete(task)
        db.commit()
        return ("", 204)
    finally:
        db.close()


# -----------------------------------------------------------------------------
# API: Bulk delete
# -----------------------------------------------------------------------------
@app.route("/api/tasks", methods=["DELETE"])
def bulk_delete():
    """
    Bulk delete tasks by status.

    Query params:
      - status: "all" (default) | "completed" | "active"

    Responses:
      200 OK
      {"deleted": <int>}  # number of removed items

    Notes:
      - Uses a single SQL DELETE filtered by status when provided.
      - synchronize_session=False is safe/performant for bulk operations.
    """
    status = request.args.get("status", "all")
    db = SessionLocal()
    try:
        q = db.query(Task)
        if status == "active":
            q = q.filter(Task.is_done == False)  # noqa: E712
        elif status == "completed":
            q = q.filter(Task.is_done == True)  # noqa: E712
        count = q.delete(synchronize_session=False)
        db.commit()
        return jsonify({"deleted": count})
    finally:
        db.close()


# -----------------------------------------------------------------------------
# Healthcheck & UI
# -----------------------------------------------------------------------------
@app.route("/health")
def health():
    """
    Lightweight liveness probe.

    Returns:
      200 OK with {"status": "ok"}
    """
    return {"status": "ok"}


@app.route("/")
def index():
    """
    Serve the main HTML page (frontend shell).
    The UI (HTML/CSS/JS) consumes the JSON API endpoints above.
    """
    return render_template("index.html")


# -----------------------------------------------------------------------------
# Entrypoint (dev)
# -----------------------------------------------------------------------------
if __name__ == "__main__":
    # For development: enables auto-reload & debug messages.
    # In production behind a WSGI server (gunicorn/uwsgi), run without this block.
    app.run(debug=True)
